<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .box {
      width: 200px;
      height: 200px;
      background-color: #ccc;
    }
  </style>
</head>

<body>
  <button class="btn">按钮</button>
  <div class="box"></div>
  <script>
    // let 和 const 创建变量

    // 没有变量声明提升
    // 不允许重复声明
    // 拥有块级作用域 {} 就是作用域
    // const 用于定义常量(永远不会改变的变量) 不能被修改 一般命名全部写, 声明的时候必须赋值
    // let 和 const 创建的全局变量不是 window 下的属性了

    // let a
    // if(true) {
    //   a = 100
    // }
    // console.log(a);

    // 变量的解构赋值
    // let user = {
    //   username: '第嘉',
    //   userage: 5
    // }
    // let username = user.username
    // let userage = user.userage
    // 对象的解构赋值
    // let { userage, username } = user

    // 对象的解构赋值重命名
    // let { userage:age , username } = user

    // console.log(username);
    // console.log(age);

    // 数组的解构赋值
    // let [a, b, c] = [1, 2, 3];

    // 字符串的结构赋值
    // let [aa, bb, cc] = 'hello'
    // console.log(aa, bb, cc);

    // 函数参数的解构赋值
    // 传递参数必须是 user 对象
    // function showName({ username }) {
    //   console.log('一顿操作展示 姓名' + username);
    // }
    // showName(user)

    // 使用解构赋值交换变量的值
    // let x = 100
    // let y = 200

    // ;[x, y] = [y, x]

    // console.log(x, y)

    // 字符串的扩展 
    // 1. 模板字符串
    // let name = 'xx'
    // console.log(`我的名字是${name}`)

    // console.log(Math.trunc(-1.1111111))

    // console.log(typeof 123n);

    // 函数参数默认值
    // function point(x = 1, y = 2) {
    //   // 如果没有传递 x y 函数调用的时候展示的就是 undefined 不友好，需要提供默认值

    //   console.log(`(${x},${y})`)
    // }

    // point(10,20)

    // 箭头函数
    // 函数的新写法
    // 只能使用变量式创建
    // 箭头函数不能当做构造函数
    // function add(a, b) {
    //   return a + b
    // }
    // let fun1 = function () {
    //   console.log(1111);
    // }



    // 箭头函数 箭头左侧 
    // 参数部分 没有参数必须写 () , 有参数可在括号里面写参数,只有一个参数 可以省略() 直接写参数
    // 箭头函数 箭头右侧
    // 函数的执行内容部分 直接写 {} 里面写需要执行的语句包括 return，当函数内部只有返回值的时候 可以省略 {} 以及 return 直接写返回值, 还有的时候，函数内部只有一步操作，而且不需要返回值，那么也可以直接省略 {} 直接写操作,也就是直接将操作当成返回值了(因为函数不需要返回值，所以无所谓)。
    // 当函数没有其他操作只是返回一个对象的话，那么可以写成 ({})
    // let fun = () => {
    //   console.log(1111);
    // }
    // let fun1 = a => Math.trunc(a)
    // let fun2 = (a, b) => a + b
    // let fun3 = (a, b) => {
    //   a ++
    //   b ++
    //   return a + b 
    // }
    // let fun4 = (arr, num) => arr.push(num)
    // let arr = [1,2,3]
    // let res = fun4(arr, 400)
    // console.log(arr)
    // console.log(res)
    // 箭头函数和普通函数内的 this 指向 不同
    // let obj = {
    //   username: '第嘉',
    //   say: () => {
    //     console.log(this);
    //     console.log(this.username);
    //   }
    // }
    // obj.say()
    // 箭头函数创建的时候就绑定 this 指向
    // 如果不是在 class 内创建的箭头函数，内部的 this 基本都是 window
    // 箭头函数 不能使用arguments
    // let fun1 = (a,b) => ({username : a, userage: b})

    // 数组的方法中使用箭头函数
    // let arr = [1,2,3,4,5,6]
    // let res = arr.filter(function (ele) {
    //   return ele%2 === 1
    // })
    // let res = arr.filter(ele => ele%2 === 1)
    // console.log(res);

    // let arr1 = [23,34,54,23,112,345,67,43]
    // let res = arr1.reduce((res, ele)=> res + ele, 0)
    // console.log(res)

    // let res1 = arr1.every(ele => ele%2 === 0)
    // console.log(res1)


    // try {
    //   console.log(a);
    // } catch (error) {
    //   console.log('失败了' + error);
    // }

    // 函数的剩余参数
    // 函数实参的集合     rest 剩余参数   是一个数组
    // 剩余参数只能当做函数参数的最后一个
    // 箭头函数内同样可以使用
    // function fun(a,...rest) {
    //   console.log(rest);
    // }
    // fun(1,2,3,4,5,6,7,8)

    // 对象的扩展
    // 1. 简洁表示
    // let obj = {
    //   a: 10,
    //   // 对象内的方法可以直接省略 function 
    //   say(){
    //     console.log(this.a);
    //   }
    // }

    // let username = 'haha'
    // let userage = 5

    // 当属性名与属性值表示的变量名相同的时候，创建的对象可以简写如下
    // let user ={
    //   username,
    //   userage
    // }

    // 2.属性名表达式 
    // 就是可以用一些特殊的内容当作属性名
    // let obj = {}
    // obj['a' + 'bc'] = 123;
    // console.log(obj);

    // 3. 对象属性的遍历
    // （1）for...in
    // （2）Object.keys(obj) 不可遍历 不可枚举属性
    // （3）Object.getOwnPropertyNames(obj) 可以遍历 不可枚举属性

    // let obj = {
    //   a: 10,
    //   b: 20
    // }
    // Object.defineProperty(obj, 'c', {
    //   writable: true,
    //   value: 30,
    //   enumerable: false
    // })
    // console.log(obj);
    // console.log(Object.keys(obj));
    // console.log(Object.getOwnPropertyNames(obj));

    // 4. 对象的扩展运算符  浅拷贝对象
    // let point = {
    //   x: 10,
    //   y: -10,
    //   theme: {
    //     color: 'red',
    //     bgColor: 'blue'
    //   }
    // }

    // 相当于拷贝了 point 对象
    // let pointCopy = {...point}

    // pointCopy.z = 5
    // pointCopy.theme.color = 'gray'
    // console.log(pointCopy);
    // console.log(point);

    // let arr = [1,2,3]
    // let arrCopy = [...arr]
    // arrCopy.push(4)
    // console.log(arr);
    // console.log(arrCopy);


    // null 判断运算符
    // let response = {
    //   msg: 0
    // }
    // 当我需要从后端获取的数据对象 response 中， 获取 msg 属性的属性值时， 如果没有该属性那么就使用默认值，如果有就用该值
    // let defaultValue
    // if(response.msg === undefined  ||response.msg === null){
    //   defaultValue  = '默认值'
    // }else{
    //   defaultValue = response.msg
    // }

    // 下面的赋值运算只有在 ?? 前面是 null | undefined 的时候才会赋值后面的值
    // let defaultValue = response.msg ?? '默认值'

    // Symbol
    // const x = Symbol('13123')
    // const y = Symbol('13123')
    // console.log(x === y);

    // 使用 Symbol 当作对象的属性名


    // const obj = {
    //   name: 'xx',
    //   age: 10
    // }

    // obj.name = 'xxx'

    // console.log(obj)

    // obj = {
    //   name: 'xxxxxx',
    //   age: 10
    // }

    // Set 数据结构(内置对象)
    // 类似于数组  但是没有重复成员
    // 创建 可以传递数组参数来创建 set 
    // let set = new Set()
    // 属性 
    // size 成员个数
    // 方法
    // add(value)：添加某个值，返回 Set 结构本身。
    // delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
    // has(value)：返回一个布尔值，表示该值是否为Set的成员。
    // clear()：清除所有成员，没有返回值。
    // forEach 遍历
    // set.add(1)
    // set.add(2)
    // set.add(2)
    // set.add(2)
    // set.add(2)
    // console.log(set);
    // 利用 Set 数据结构对数组进行去重
    // let arr = [1,212,1,2,1,3,312,3,123]
    // let set = new Set(arr)
    // // Set 转化成数组
    // console.log([...set]);
    // let newArr = []
    // set.forEach(ele => {
    //   console.log(ele);
    //   newArr.push(ele)
    // })
    // console.log(newArr);

    // Map  可以用任意的值当作属性名
    // let btn = document.querySelector('.btn')
    // let a = {b : 20}
    // let c = {m : 20}
    // let obj = {
    //   [btn]: '啊哈哈哈',
    //   [a]: 1000,
    //   [c]: 19999
    // }
    // console.log(obj);

    // let  map = new Map()
    // 属性 
    // size 属性的个数

    // 方法
    // set 设置属性
    // get 获取属性值
    // has 是否存在某个属性
    // delete 删除属性
    // clear 清空 map
    // forEach
    // map.set(a, '11111')
    // map.set(c, '11111')
    // map.set(btn, btn)
    // console.log(map.get(btn));


    // class  原来的构造函数和原型的新写法
    // function Cat(name, age) {
    //   this.name = name 
    //   this.age = age
    // }

    // Cat.prototype.say = function () {
    //   console.log('喵喵喵');
    // }

    // const cat = new Cat('大花儿', 2)
    // console.log(cat);

    // function TianYuanCat(name, age) {
    //   Cat.call(this,name, age)
    // }

    // TianYuanCat.prototype = Cat.prototype    // new Cat()
    // TianYuanCat.prototype.constructor = TianYuanCat

    // let myCat = new TianYuanCat('小二',2)
    // console.log(myCat);
    // myCat.say()

    // class {}  一般只能写方法 ，而且方法之间不需要符号
    // class Cat {
    //   // constructor 是 class 默认自带的方法
    //   // constructor 就相当于之前的构造函数
    //   // 不需要传值就创建的属性
    //   type = '猫'

    //   constructor(name, age, nickname) {
    //     this.name = name
    //     this.age = age
    //     // nickname 由两部分组成 是一个字符串 用空格隔开
    //     this.nickname = nickname
    //     // this.type = '猫'
    //   }
    //   // 其他的 非 constructor 方法就相当于之前写在 prototype 原型内的

    //   // 创建的方法 写不写等号 区别是 写等号的相当于在构造函数中创建的，不写的相当于在 原型中
    //   // say() {
    //   //   console.log(this.name);
    //   // }
    //   // say = function() {
    //   //   console.log(this.name);
    //   // }
    //   // 当你想用箭头函数创建方法的时候必须用 赋值方式
    //   say = () => {
    //     console.log(this.name);
    //   }
    //   // 在类内可以直接使用 get 和 set 对属性进行存取描述
    //   // get 计算属性， 对原有的属性进行计算
    //   get firstNickname() {
    //     return this.nickname.split(' ')[0]
    //   }
    //   // set 修改计算属性, 其实就是修改计算属性的来源
    //   set firstNickname(value) {
    //     // 就是修改 nickname
    //     let arr = this.nickname.split(' ')
    //     arr[0] = value 
    //     this.nickname = arr.join(' ')
    //   }
    //   // 静态方法 之前直接使用 构造函数.xx 创建
    //   // 是直接绑定在 class 上的 也就是 Cat.fun
    //   static sayInfo(){
    //     console.log('我是猫科类动物');
    //   }
    // }
    // let cat = new Cat('小白', 1, 'x test')
    // // new Cat 的时候会触发 constructor 函数， this 指向实例化对象
    // cat.say()
    // cat.color = 'black'
    // cat.firstNickname = 'xx'
    // console.log(cat);
    // Cat.sayInfo()
    // cat.say()





    // class 
    // class Animal {
    //   // 属性的新写法
    //   hobby = ['eat']
    //   constructor(name, age){
    //     this.name = name
    //     this.age = age 
    //     this.x = 100
    //   }
    //   say(){
    //     console.log('我的名字是'+this.name)
    //   }
    //   // say = () => {
    //   //   console.log('我的名字是'+this.name)
    //   // }
    //   // 计算属性
    //   // get introStr () {
    //   //   return '我的名字是' + this.name+ ',' + '今年' + this.age + '岁了。'
    //   // }
    //   // set introStr(value) {
    //   //   // console.log(value)
    //   //   this.name = '小花儿'
    //   //   this.age = 2
    //   // }

    //   // 类的方法  并不是实例化对象的方法 只有类才能调用
    //   static showIntroStr () {
    //     console.log(this.introStr);
    //   }
    // }
    // const animal = new Animal('小蓝儿', 3)
    // animal.introStr = '我的名字是小花儿今年2岁了。'
    // console.log('我的名字是' + animal.name+ ',' + '今年' + animal.age + '岁了。');
    // Animal.showIntroStr()

    // class 的继承

    // class Dog extends Animal{
    //   a = '汪汪汪'
    //   constructor(name, age){
    //     super(name, age)
    //   }
    // }

    // const dog = new Dog('大黑', 3)

    // console.log(dog)
    // Object.getPrototypeOf(子类) 获取子类 class 继承的父类 class
    // console.log(Object.getPrototypeOf(Dog))

    // console.log(Dog.prototype);

    // Promise 
    // 异步编程解决方案

    // document.querySelector('.btn').onclick = function() {
    //   requestAnimationFrame(move)
    //   console.log(11111111);
    // }
    // let num = 0
    // function move() {
    //   console.log(2222222);
    //   num ++ 
    //   document.querySelector('.box').style.transform =  `translateX(${num}px)`
    //   requestAnimationFrame(move)
    // }

    // 左   右(判断)  上   下
    // 回调函数解决异步操作问题
    // 回调地狱
    // $('.xxx').xxx(1000, function () {
    //   $('.xxx').xxxx(10000, function () {
    //     if(true){
    //       $().xxx(10000, function () {

    //       })
    //     }else{
    //       $().xxx(10000, function () {

    //       })
    //     }
    //   })
    // })

    // 使用 promise 解决

    // Promise 是一个构造函数(类) 需要一个实例化的 promise 来解决异步
    // 将 异步操作封装到 promise 中，来解决异步
    // 参数是一个函数, 这个参数函数接收两个参数  resolve  reject, 这两个参数都是函数
    // let x = function (num) {
    //   return new Promise(function (resolve, reject) {
    //     let a = 100
    //     setTimeout(function () {
    //       // 异步回调
    //       // resolve 表示异步成功结束要做的事
    //       a = 150
    //       if(a > 100){
    //         console.log(num)
    //         resolve(a)
    //       }else{
    //         reject('a 的结果出错啦')
    //       }
    //     }, 1000)
    //   })
    // }
    // promise 实例化的(new)时候 传递的参数函数会立即出发， 所以一般将实例化 promise(封装异步) 放到函数内, 并且将 实例(new 的结果)返回
    // promise 实例的 then 方法就是要传递 resolve 函数的, resolve 的返回值就是 then 的返回值
    // x(1).then(res => {
    //   console.log(res)
    //   return x(2)
    // }).catch(err => {
    //   console.log(err)
    // }).then(res => {
    //   console.log(res);
    // })
    // promise 的三个状态
    // pending 进行中
    // fulfilled（已成功） resolved
    // rejected（已失败）


    // 除了 then catch 还有 finally 方法


    // Promise 构造函数 还有几个静态方法
    // Promise.all

    let p1 = () => new Promise((resolve, reject) => {
      setTimeout(() => {
        let res = '失败1'
        if (res === '成功1') {
          resolve(res)
        } else {
          reject(res)
        }
      }, 1000)
    })

    let p2 = () => new Promise((resolve, reject) => {
      setTimeout(() => {
        let res = '失败2'
        if (res === '成功2') {
          resolve(res)
        } else {
          reject(res)
        }
      }, 2000)
    })

    let p3 = () => new Promise((resolve, reject) => {
      setTimeout(() => {
        let res = '失败3'
        if (res === '成功3') {
          resolve(res)
        } else {
          reject(res)
        }
      }, 3000)
    })

    // 同时执行三个异步操作，但是要求三个异步全部执行完毕之后再去执行一些事，此时可以使用 Promise.all

    // Promise.all   p1 p2 p3 全部执行 resolve 了，整个 all 就会执行 then 得到的结果是三个成功的， p1 p2 p3 只要有一个 reject 了，那整个 all 执行的就是 catch 得到的结果就是失败的那个
    // Promise.all([p1(), p2(), p3()]).then(res => {
    //   console.log(res);
    // }).catch(err=> {
    //   console.log(err)
    // })

    // Promise.race
    // p1 p2 p3 之中有一个先执行了 resolve ，那么 react会执行 then 得到 resolve 的结果，如果有一个 reject 先执行了，那么 race 就会执行 catch, 得到 reject 的结果
    // Promise.race([p1(), p2(), p3()]).then(res => {
    //   console.log(res);
    // }).catch(err=> {
    //   console.log(err)
    // })

    // Promise.allSettled
    // p1  p2  p3 无论完成未完成都会的到结果
    // Promise.allSettled([p1(), p2(), p3()]).then(res => {
    //   console.log(res);
    // }).catch(err=> {
    //   console.log(err)
    // })

    // Promise.any
    // p1  p2  p3 如果出现了 resolve 了，那么 any 就会执行 then 得到 resolve 的结果。如果三个都执行了 reject 那么 any 就会执行 catch 得到失败的提示
    // Promise.any([p1(), p2(), p3()]).then(res => {
    //   console.log(res);
    // }).catch(err=> {
    //   console.log(err)
    // })




    // 使用 Generator 解决    简写语法 async
    // Generator 函数
    // function* helloWorldGenerator() {
    //   console.log('Generator 函数')
    //   yield 'hello';
    //   yield 'world';
    //   return 'ending';
    // }
    // let hw = helloWorldGenerator()
    // Generator 函数调用之后函数内部并不会执行也不会返回对应的值， 而是返回一个对象 ， 需要调用对象下的 next 方法
    // console.log(hw)
    // let res = hw.next()
    // let res1 = hw.next()
    // let res2 = hw.next()
    // let res3 = hw.next()
    // console.log(res)
    // console.log(res1)
    // console.log(res2)
    // console.log(res3)
    
  </script>
</body>

</html>